MELECHDSP RUNBOOK — PRESETS_AB_BYPASS_V1
Project: AnalyzerPro
Scope: UI + preset storage + state management (NO DSP redesign)

================================================================
GLOBAL RULES
================================================================

Obey 00_SYSTEM_RULES.txt.

This runbook allows:
- Plugin state management changes
- Preset storage/load logic
- UI wiring for preset controls
Still enforce:
- Minimal diffs
- No formatting-only edits
- STOP after each step

================================================================
OBJECTIVE
================================================================

Add a complete preset system to AnalyzerPro:
1) Presets: Save / Load / Factory
2) A/B state compare (A and B slots)
3) Bypass button
4) Save as Default Preset (auto-load on new instance)

Requirements:
- Works reliably across hosts
- Presets include all user-facing parameters (APVTS state)
- Does not break existing automation
- UI uses mdsp_ui::UiContext (Theme/Metrics/Typography)
- Clear separation: preset logic not embedded inside UI rendering

Non-goals (v1):
- Cloud sync
- Preset tagging/search
- Per-host preset formats
- Undo stack

================================================================
DECISIONS (LOCK BEFORE CODING)
================================================================

Lock these rules and document them in code comments in the preset manager:

A) Preset format:
- Use ValueTree (APVTS.copyState()) serialized to XML or binary.
Recommended: XML via ValueTree::toXmlString() for readability.

B) Preset storage location (standalone file presets):
- Use juce::File::getSpecialLocation for user application data.
Recommended:
  userApplicationDataDirectory / "MelechDSP" / "AnalyzerPro" / "Presets"

C) Default preset:
- Stored as a dedicated file:
  "Default.preset" in the same preset folder
- Loaded on plugin initialization if exists
- If missing: load Factory preset

D) Factory preset:
- Embedded in code as a ValueTree snapshot OR generated by resetting APVTS to defaults.
Recommended: reset to parameter defaults (no file required) + optionally include named factories later.

E) A/B behavior:
- A and B store full parameter state snapshots
- Switching A/B loads that snapshot into APVTS
- Switching does NOT overwrite the other slot automatically
- Provide explicit “Copy A→B” and “Copy B→A” only if requested later (not required v1)

F) Bypass behavior:
- UI bypass: when enabled, processing should be bypassed (if applicable)
- If plugin has no processing, bypass may only bypass meters/analyzer updates OR serve as UX standard.
Lock exact meaning:
  - Option 1: bypass DSP processing (preferred if there is audio processing)
  - Option 2: bypass analysis update (acceptable for analyzer-only plugin)
Document the choice clearly.

STOP AFTER DONE

================================================================
STEP 1 — PRESET MANAGER (CORE LOGIC)
================================================================

TASK:
Implement a PresetManager class (plugin-side, not mdsp_ui).

Responsibilities:
- Save preset to file
- Load preset from file
- Enumerate presets in folder
- Apply preset to APVTS safely on message thread
- Provide Factory reset
- Save/Load Default preset

Rules:
- No UI code inside PresetManager
- No allocations in audio thread
- Host-safe state changes: apply on message thread

Implementation requirements:
1) API sketch (example):
   - getPresetFolder()
   - listPresets()
   - savePreset(name)
   - loadPreset(file or name)
   - loadFactory()
   - saveDefault()
   - loadDefaultOrFactory()
2) Preset file extension: ".mdspreset" (or ".preset") — choose one and stick to it
3) Use APVTS state snapshot:
   - ValueTree state = apvts.copyState();
   - serialize / deserialize
4) Apply preset:
   - apvts.replaceState(state);
   - ensure UI updates

Acceptance:
- Can save/load from disk
- Can reset to factory
- Can save/load default
- No host crashes

STOP AFTER DONE

================================================================
STEP 2 — A/B STATE MANAGER
================================================================

TASK:
Implement A/B slot storage and switching.

Responsibilities:
- Store ValueTree snapshot for slot A and slot B
- Track active slot (A or B)
- Switch active slot and apply stored state to APVTS
- Initialize both slots from current state on startup

Rules:
- No disk I/O required for A/B (in-memory is fine)
- No UI code inside manager
- Switching must be fast and deterministic

Acceptance:
- A/B switching restores correct parameter sets
- No parameter drift

STOP AFTER DONE

================================================================
STEP 3 — BYPASS PARAMETER / STATE
================================================================

TASK:
Add a bypass mechanism.

Preferred implementation:
- Add an APVTS bool parameter: "bypass"
- Or a processor-owned atomic bool if you do not want automation

Rules:
- Define and document what bypass means for AnalyzerPro
- UI must reflect bypass state
- If bypass affects analysis, ensure visuals update accordingly (e.g., freeze or show BYPASS overlay)

Acceptance:
- Bypass toggles on/off reliably
- Visuals match bypass state

STOP AFTER DONE

================================================================
STEP 4 — PLUGIN STATE PERSISTENCE (HOST SAVE/RECALL)
================================================================

TASK:
Ensure presets and A/B state behave with host state saving.

Rules:
- getStateInformation/setStateInformation must serialize:
  - APVTS state
  - Active A/B slot
  - A and B snapshots (if desired)
  - Optional: last loaded preset name
- Default preset is global (disk), not per-instance
- Do not break existing state

Acceptance:
- Session reload restores correct settings
- No host warnings

STOP AFTER DONE

================================================================
STEP 5 — UI CONTROLS (HEADERBAR RECOMMENDED)
================================================================

TASK:
Add UI controls:
- Preset dropdown/list
- Save button
- Load button (or selecting from dropdown loads)
- Factory button
- A button
- B button
- Bypass button
- Save Default button (or menu item)

Placement recommendation:
- HeaderBar (top right/left cluster)
- Use compact pill buttons to fit existing style

UI rules:
- Use mdsp_ui::UiContext tokens only
- No magic sizes/colors
- Use existing control patterns (ChoiceRow, Pill buttons, etc.)
- UI must call into managers; no preset logic in paint()

Behavior rules:
- Selecting preset loads immediately OR requires “Load” button (choose one)
- Save prompts for name (simple modal dialog) OR saves current name (choose one)
- Save Default: single click saves current state as Default.preset

Acceptance:
- UI controls work end-to-end
- Visual state updates
- No crashes

STOP AFTER DONE

================================================================
STEP 6 — FACTORY PRESET CONTENT
================================================================

TASK:
Define factory state.

Options:
A) Reset parameters to default values via APVTS parameter defaults
B) Hardcode a ValueTree factory snapshot (only if needed)

Pick A by default.

Acceptance:
- Factory button returns to expected baseline

STOP AFTER DONE

================================================================
STEP 7 — VALIDATION
================================================================

Checklist:
- Save preset -> file created -> reload works
- Preset list updates
- Default preset saves and loads on new instance
- Factory resets correctly
- A/B switching restores correctly
- Bypass state is correct and reflected in visuals
- Host session save/recall works

STOP AFTER DONE

================================================================
END OF RUNBOOK
================================================================